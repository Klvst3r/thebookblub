Ofuscaci√≥n y Validaci√≥n de Contrase√±as en Yii Framework


Resumen
-------

Resumen
¬øC√≥mo asegurar contrase√±as en Yii?

El marco de trabajo Yii ofrece m√∫ltiples herramientas para manejar de forma segura la informaci√≥n de usuario, especialmente las contrase√±as. A trav√©s de las funciones before y after en cada paso del modelo, podemos realizar un tratamiento espec√≠fico de los datos durante su procesamiento. Un ejemplo com√∫n es el manejo de contrase√±as, donde debemos asegurarnos de que est√©n ofuscadas antes de guardarlas en la base de datos.
¬øQu√© son los m√©todos before save y after save?

Los m√©todos before save y after save pertenecen a la clase modelo de Yii y nos permiten ejecutar c√≥digo antes y despu√©s de guardar los datos. Estos m√©todos facilitan el seguimiento de la informaci√≥n y permiten ejecutar tratamientos especiales, como ofuscar contrase√±as.

Para ofuscar contrase√±as, primero validamos que contengan los caracteres requeridos, y antes de salvarlos, transformamos el texto claro (por ejemplo, "patito 123") aplicando una funci√≥n de hash como MD5 combinada con otros par√°metros como el nombre de usuario y una "sal" del sistema.
Implementaci√≥n de before save para contrase√±as

Aqu√≠ hay un ejemplo de c√≥mo implementar el m√©todo before save para manejar contrase√±as:

public function beforeSave($insert)
{
    if (parent::beforeSave($insert)) {
        if ($insert) { // Nuevo usuario
            $this->password = $this->ofuscatePassword($this->password);
        }
        return true;
    } else {
        return false;
    }
}

protected function ofuscatePassword($password)
{
    $salt = getenv("SALT");
    if (empty($salt)) {
        throw new Exception("noSalt");
    }
    return md5(sprintf('%s%s%s', $password, $this->username, $salt));
}

Ejecuci√≥n y verificaci√≥n desde l√≠nea de comandos

Para probar el manejo de usuarios y contrase√±as, utilizamos un controlador en l√≠nea de comandos que nos permite crear y verificar usuarios. As√≠ se logra que las contrase√±as se almacenen de manera segura y se puedan validar correctamente:

public function actionNew($username, $password)
{
    $user = new User();
    $user->username = $username;
    $user->password = $password;
    if ($user->save()) {
        printf("New user OK, ID: %d\n", $user->id);
    } else {
        printf("Problema creando usuario.\n");
    }
}

public function actionCheck($username, $password)
{
    $user = User::findOne(['username' => $username]);
    if (!empty($user) && $user->password === $user->ofuscatePassword($password)) {
        printf("Login v√°lido\n");
    } else {
        printf("Nel\n");
    }
}

Para verificar que la funcionalidad est√° implementada correctamente, se pueden ejecutar comandos como:

    Crear un nuevo usuario:

    php yii user/new "username" "password"

    Comprobar el usuario:

    php yii user/check "username" "password"

Beneficios de usar un sistema de hashing

El uso de un sistema de hashing para contrase√±as ofrece grandes beneficios en t√©rminos de seguridad:

    Protecci√≥n de datos sensibles: Las contrase√±as se almacenan como hashes, no como texto plano. Esto dificulta el acceso a las contrase√±as originales por parte de intrusos.

    Mayor seguridad con "sal": La "sal" a√±ade un extra a la seguridad, haciendo que incluso contrase√±as id√©nticas no generen el mismo hash en diferentes cuentas de usuario.

    Integridad en las validaciones: Permite realizar validaciones confiables del lado del servidor asegurando que las credenciales coincidan correctamente con el hash almacenado.

Este enfoque otorga un nivel adicional de seguridad en el manejo de usuarios y contrase√±as dentro de un sistema Yii, protegiendo efectivamente la informaci√≥n cr√≠tica.


Referencias:
------------
https://www.yiiframework.com/doc/api/2.0/yii-base-model#behaviors()-detail/


Comentarios:
------------


Maestro: ¬øC√≥mo debo vincular el archivo: variables_local.sh que lo tengo en el directorio: local, ya que Yii me marca error y no me reconoce ninguna variable de entorno.

Para que todo me funcione como se indica en este video 22, es necesario que d√© alta manualmente, cada variable de entorno al sistema de windows que tengo.

Deseo resolver esta situaci√≥n para continuar con este Curso tan excelente. Gracias.
Compan;ero estudiante, por favor chekar nuevamente la clase 6. (Configuraci√≥n de variables de entorno) Alli en los comentarios encuentras la solucion a como cargar las variables de entorno en un ambiente de desarrollo windows. 


Proceso:
--------

Se esta cambiando completamente el origen de datos, antes de probar se vera:

Cuando una persona indroduce su usuario y pass, el password, ya se manda todo el paquete de informaci√≥n a la maquina, y ese password queda en claro, en ningun momento, se esta pidicendo que se ofisque para guardarlo. simplemete se hace el save y directamente a la bd.

Yii ofirece los before y after en cada paso del modelo, entre que el usuario manda toda la inforamci√≥n para crearse el modelo, before validate, after validate, 

Son funciones que vienen desde la clase modelo, y nos ayudan a darle un seguimiento a esta informaci√≥n y  si queremos hacer alguntratamiento puntual ejecutarlo.

En este casoparticular, ara buscar el password necesitamos ofiscarlo, despues de validar, no se esta refiriendo a que el password se al correcto si no que el password tenga la cantidad de caracteres y demas, necesitamos que antes de salvarse cambie, del texto claro, 

pass123 a que pase pro esta funcion de ofiscatedPassword

Que es el md5 del sprinft de las 3 variables que se pusieron, el password, el usarname y la salt que esta en el sistema.

Vamos a hacer antes una cosa mas, 





    public function ofuscatePassword($password) {

        if(empty(getenv('salt'))){
            throw new Exception('no salt');
        }
        return md5(sprintf('%s-%s-%s', $password, $this->username, getenv('salt')));
    }

Para probar creamos
Si insert es true significa que se esta guardando por primera vez en la bd, si es false significa que esta actualizando algo que ya existia.


Este tipo de funciones before, validate, before save, after save, todas devuelven un booleano y es importante que tengamos en cnuenta esto.

Hagamos lo que hagamos, debemos a tomar en cnuenta el parent, 


public function beforeSave($insert){
         return parent::beforeSave($insert);
    }

Esta funcion no hace albsolutamente nada, pero es correcta significa que yo ejecuto todo y despues si yo voy a mandar un true, necesito, tomar en cuenta al padre que es el modelo como tal.

Por eso si.

 public function beforeSave($insert){
        if($insert == true){    //significa que esta haciendo la primera vez un usuario
            $this->password = $this->ofuscatePassword($this->password);
        }
         return parent::beforeSave($insert);
    }


Ahora vamos a hacer un usuario desde la linea de comandos    

 

en el archivo
commands/UserControler.php


<?php

namespace app\commands;

use yii\console\Controller;
use yii\console\ExitCode;

use app\models\User;


class UserController extends Controller {

    public function actionNew($username, $password) {

    }

    public function checkPassword($username, $password) {

    }
}


Empezando a crear un usuario 


public function actionNew($username, $password) {
        $user = new User;
        $user->username = $username;
        $user->password = $password;
        if($user->save()){ //Si logra salvar
            printf("new user ok, id: %d\n", $username, $password);
        }else{
            printf("Problama creando usuario \n");
        }

        return ExitCode::OK;


    }

Ahora en la terminal    

Si escribimos yii debemos ya tener user

Ejecutamos $ php yii veremos que ya tendremos y podremos ejecutar

    - user                         
    user/new

Entonces

    $ php yii user/new klvst3r desarrollo


Antes de dar enter para crear el usuario veremos la bd en la pesta√±a UserControler

select * from users;

ejecutamos ahora el comando


Al crear el usuario genero un error

php yii user/new klvst3r desarrollo
Exception 'Exception' with message 'no salt'

in /home/klvst3r/dev/yii/thebookblub/models/User.php:140

Stack trace:
#0 /home/klvst3r/dev/yii/thebookblub/models/User.php(147): app\models\User->ofuscatePassword()
#1 /home/klvst3r/dev/yii/thebookblub/vendor/yiisoft/yii2/db/ActiveRecord.php(600): app\models\User->beforeSave()
#2 /home/klvst3r/dev/yii/thebookblub/vendor/yiisoft/yii2/db/ActiveRecord.php(570): yii\db\ActiveRecord->insertInternal()
#3 /home/klvst3r/dev/yii/thebookblub/vendor/yiisoft/yii2/db/BaseActiveRecord.php(688): yii\db\ActiveRecord->insert()
#4 /home/klvst3r/dev/yii/thebookblub/commands/UserController.php(17): yii\db\BaseActiveRecord->save()
#5 [internal function]: app\commands\UserController->actionNew()
#6 /home/klvst3r/dev/yii/thebookblub/vendor/yiisoft/yii2/base/InlineAction.php(57): call_user_func_array()
#7 /home/klvst3r/dev/yii/thebookblub/vendor/yiisoft/yii2/base/Controller.php(178): yii\base\InlineAction->runWithParams()
#8 /home/klvst3r/dev/yii/thebookblub/vendor/yiisoft/yii2/console/Controller.php(180): yii\base\Controller->runAction()
#9 /home/klvst3r/dev/yii/thebookblub/vendor/yiisoft/yii2/base/Module.php(552): yii\console\Controller->runAction()
#10 /home/klvst3r/dev/yii/thebookblub/vendor/yiisoft/yii2/console/Application.php(180): yii\base\Module->runAction()
#11 /home/klvst3r/dev/yii/thebookblub/vendor/yiisoft/yii2/console/Application.php(147): yii\console\Application->runAction()
#12 /home/klvst3r/dev/yii/thebookblub/vendor/yiisoft/yii2/base/Application.php(384): yii\console\Application->handleRequest()
#13 /home/klvst3r/dev/yii/thebookblub/yii(20): yii\base\Application->run()
#14 {main}


Esto ocurre porque la funci√≥n ofuscatePassword() intenta acceder a una variable de entorno llamada salt, pero esta no est√° definida.

Soluci√≥n

Debemos definir la variable de entorno salt. Aqu√≠ dos formas para resolverlo:

1. Definir la variable salt en el entorno (recomendado)

Agrega esta l√≠nea en el archivo .env en la ra√≠z de tu proyecto (si no existe, cr√©alo):

SALT=mi-sal_secreta

Luego, aseg√∫rate de que Yii est√© cargando las variables de entorno. En el archivo config/web.php y config/console.php, debes tener algo as√≠:

// config/console.php

// Al principio del archivo
$dotenv = Dotenv\Dotenv::createImmutable(__DIR__ . '/../');
$dotenv->load();

    Si no est√°s usando vlucas/phpdotenv, inst√°lalo con:

    $ composer require vlucas/phpdotenv


Opci√≥n 2 (r√°pida): Definir salt directamente en el entorno de consola temporalmente

Puedes pasarla directamente al ejecutar el comando:

SALT=mi-sal_secreta php yii user/new klvst3r desarrollo

Esto define SALT para ese solo comando. Pero no es persistente ni seguro para producci√≥n.



Opci√≥n 3: Definir un valor por defecto en el c√≥digo (no recomendado para producci√≥n)

Puedes modificar el m√©todo ofuscatePassword() as√≠:

public function ofuscatePassword($password) {
    $salt = getenv('salt') ?: 'default_salt';
    return md5(sprintf('%s-%s-%s', $password, $this->username, $salt));
}

Esta opci√≥n evita el error, pero usar un salt por defecto puede comprometer la seguridad.    


Esta tercera opcion funciono y ahora debemos deterr nuestro usuario en la bd

Creamos nuestro usuario
    php yii user/new klvst3r desarrollo



Verificamos en la bd

select * from users;
+---------+----------+----------------------------------+----------+--------------+---------------------+---------------------+
| user_id | username | password                         | auth_key | access_token | created_at          | modified_at         |
+---------+----------+----------------------------------+----------+--------------+---------------------+---------------------+
|       1 | klvst3r  | fa0be8b7f602bbd62f22585c5ffbe377 | NULL     | NULL         | 2025-06-12 12:07:03 | 2025-06-12 12:07:03 |
+---------+----------+----------------------------------+----------+--------------+---------------------+---------------------+
1 row in set (0.001 sec)


select * from users\G;
*************************** 1. row ***************************
     user_id: 1
    username: klvst3r
    password: fa0be8b7f602bbd62f22585c5ffbe377
    auth_key: NULL
access_token: NULL
  created_at: 2025-06-12 12:07:03
 modified_at: 2025-06-12 12:07:03
1 row in set (0.000 sec)


Tomando en cosideraci√≥n que tenemos variables de entorno configuradas en 
/local/variables_local.sh

/local/variables_local.fish

Recomendaci√≥n profesional para producci√≥n
--------------------------------------


1. Mant√©n variables en archivos separados del repositorio

Tu enfoque actual es correcto en t√©rminos de mantener las variables en archivos como variables_local.sh y variables_local.fish. Solo aseg√∫rate de que estos archivos:

    No est√©n versionados en Git: agr√©galos a tu .gitignore:

/local/variables_local.sh
/local/variables_local.fish

Est√©n cargados al iniciar el entorno, por ejemplo, en tu .bashrc, .zshrc o .config/fish/config.fish:

Para Bash/Zsh:

source /ruta/a/proyecto/local/variables_local.sh

Para Fish:

    source /ruta/a/proyecto/local/variables_local.fish


2. Elimina el valor por defecto en producci√≥n

Una vez que tengas bien definidas las variables en tu entorno, puedes regresar al m√©todo original en tu modelo User.php para evitar valores por defecto inseguros:

public function ofuscatePassword($password) {
    $salt = getenv('salt');
    if (empty($salt)) {
        throw new Exception('no salt');
    }
    return md5(sprintf('%s-%s-%s', $password, $this->username, $salt));
}

As√≠ fuerzas que la variable exista, y evitas caer en una salt por defecto.

3. Producci√≥n: usar variables de entorno del sistema o archivo .env

En servidores de producci√≥n:

    Puedes definir las variables de entorno en el entorno del sistema (/etc/environment, archivo .bash_profile, supervisor.conf, systemd u otro medio).

    O puedes utilizar la librer√≠a vlucas/phpdotenv para cargar desde un archivo .env de forma autom√°tica:

# .env
salt=uAh2hbHUPao10OyQsTz2vYym0fgmea!K

Con c√≥digo en config/console.php o config/web.php:

$dotenv = Dotenv\Dotenv::createImmutable(__DIR__ . '/../');
$dotenv->load();

Conclusi√≥n: combinaci√≥n recomendada

Entorno	M√©todo recomendado

Desarrollo	variables_local.sh o .env cargado desde .bashrc o phpdotenv
Producci√≥n	Variables de entorno del sistema o .env (nunca en c√≥digo)
C√≥digo fuente	Nunca incluir valores de salt ni contrase√±as



una de las recomendaciones es utilizar la libreria vlucas/phpdotenv


Ya que hemos instalado la librer√≠a vlucas/phpdotenv, estamos considero en el camino correcto. A continuaci√≥n veremos paso a paso c√≥mo crear tu archivo .env, c√≥mo cargarlo correctamente en Yii2 y c√≥mo usar la variable salt de manera segura en tu modelo User.


Paso 1: Crear el archivo .env

En la ra√≠z del proyecto (donde est√°n composer.json y la carpeta vendor), crear un archivo .env con este contenido:

# .env
salt=uAh2hbHUPao10OyQsTz2vYym0fgmea!K

    ‚ö†Ô∏è No subir este archivo al repositorio. Agregar esto al archivo .gitignore:


.env


Paso 2: Cargar las variables del .env en Yii2

Debemos cargar el .env antes de que cualquier c√≥digo que lo utilice se ejecute. Lo m√°s recomendable es hacerlo en index.php (para web) o yii (para consola).


web/index.php (para peticiones web)

Debemos Agregar esto antes de crear la aplicaci√≥n:

require __DIR__ . '/../vendor/autoload.php';

// Cargar variables del archivo .env

$dotenv = Dotenv\Dotenv::createImmutable(__DIR__ . '/../');
$dotenv->load();

require __DIR__ . '/../vendor/yiisoft/yii2/Yii.php';

$ php yii (para comandos de consola)

Agrega esto al inicio del archivo yii (ubicado en raiz del proyecto):

require __DIR__ . '/vendor/autoload.php';

// Cargar .env
$dotenv = Dotenv\Dotenv::createImmutable(__DIR__);
$dotenv->load();

require __DIR__ . '/vendor/yiisoft/yii2/Yii.php';

Paso 3: Usar la variable salt en tu modelo User

Ahora que las variables est√°n cargadas, puedes utilizar getenv('salt') sin valores por defecto:

public function ofuscatePassword($password) {
    $salt = getenv('salt');
    if (empty($salt)) {
        throw new \Exception('No salt defined in environment');
    }

    return md5(sprintf('%s-%s-%s', $password, $this->username, $salt));
}



Verificar que funciona

Puedes hacer una prueba r√°pida con un controlador o en una vista:

echo getenv('salt');  // Deber√≠a imprimir: uAh2hbHUPao10OyQsTz2vYym0fgmea!K





Bonus: Validaci√≥n de entorno

Para evitar errores en producci√≥n por falta del .env, puedes usar:

if (!file_exists(__DIR__ . '/../.env')) {
    throw new \Exception('.env file missing');
}


Para crrar una nueva clave salt aleatoria desde la terminal tenemos algunas opciones.

Opci√≥n 1: Generar una nueva salt manualmente (desde consola) y pegarla en .env

Ejecuta este comando en tu terminal:

head /dev/urandom | tr -dc A-Za-z0-9 | head -c 32

Este comando generar√° una cadena aleatoria de 32 caracteres, por ejemplo:

A9fX2mZ7qLkT4vGhR8pJcBsDnYwE0uIq

Luego simplemente abre tu archivo .env y agrega:

salt=A9fX2mZ7qLkT4vGhR8pJcBsDnYwE0uIq

Opci√≥n 2: Crear o sobrescribir la variable salt autom√°ticamente en .env con un solo comando

Este comando generar√° un nuevo valor aleatorio y lo escribir√° directamente en el archivo .env. Si ya existe, lo sobrescribe:

echo "salt=$(head /dev/urandom | tr -dc A-Za-z0-9 | head -c 32)" >> .env

    ‚ö†Ô∏è Esto agrega una nueva l√≠nea al final, lo cual puede causar duplicados si ya existe salt. Para evitar duplicados, usa esta versi√≥n que reemplaza o crea la l√≠nea correctamente:

salt_value=$(head /dev/urandom | tr -dc A-Za-z0-9 | head -c 32)
if grep -q "^salt=" .env; then
    sed -i "s/^salt=.*/salt=$salt_value/" .env
else
    echo "salt=$salt_value" >> .env
fi

    En macOS, usa sed -i '' en lugar de sed -i.

Confirmar

Una vez agregado el valor, puedes verificar que est√© cargado en PHP con:

echo getenv('salt');





# Carga de variables
Aunque ejecutemos el archivo de fish existe una confusi√≥n.


Lo que ocurre es una confusi√≥n entre el entorno del shell (Fish) y el entorno de ejecuci√≥n del servidor PHP (Apache, PHP-FPM, Laravel, CLI, etc.).

Aunque ejecutemos:

    source variables_local.fish

Y eso defina variables en nuestro terminal Fish, esas variables no estar√°n disponibles autom√°ticamente para el servidor PHP (ni v√≠a getenv()), a menos que se exporten al entorno global del proceso que ejecuta PHP. Que es lo que queremos realmente


¬øQu√© ocurre realmente?

Cuando haces:

set -x salt uAh2hbHUPao10OyQsTz2vYym0fgmea!K

-x significa export, pero solo afectamos a procesos hijos del terminal actual. Por ejemplo, si ejecutamos un script PHP desde la terminal como:

    php test.php

S√≠ estar√° disponible. Pero si est√°s usando Laravel con php artisan serve o est√°s en un servidor Apache/Nginx, PHP no tiene acceso a esa variable porque no es parte de su entorno de ejecuci√≥n.

Que es lo que nos esta ocurriendo atualmente


Recomendaciones
----

üîπ Para entorno de desarrollo (usando .env con vlucas/phpdotenv)

    En la ra√≠z de tu proyecto Laravel o PHP, crea un archivo .env:

salt=uAh2hbHUPao10OyQsTz2vYym0fgmea!K

    En nuestrp script de arranque (por ejemplo, index.php o el entry point de Laravel), aseg√∫rate de cargar las variables .env con Dotenv:

require_once __DIR__ . '/vendor/autoload.php';

$dotenv = Dotenv\Dotenv::createImmutable(__DIR__);
$dotenv->load();

    Ahora puedes acceder a la variable con:

getenv('salt'); // o
$_ENV['salt'];  // tambi√©n suele estar disponible

    ‚úîÔ∏è Esto es lo m√°s seguro y recomendado para desarrollo y producci√≥n.

üîπ Para uso temporal desde terminal

Si quieres ejecutar un script PHP desde terminal y pasarle la variable directamente sin .env:

env salt=MiClaveSegura php script.php

Dentro de script.php puedes usar:

echo getenv('salt');

üîπ Verifica que tu entorno PHP tenga la variable cargada

Crea un script test.php:

<?php
echo 'Salt: ' . getenv('salt');

Y ejec√∫talo:

php test.php

O si es en el navegador (servidor local), aseg√∫rate de tener .env y Dotenv::load() funcionando.

Con este  sistema de encruiptacion de datos, aunque el password y el usurio sea el mismo, el hash es diferente, 

ahora vamos a crear una accion en el controlador para entender, todo el sistema de seguridad visto desde adentro.


 public function actionCheck($username, $password) {
        $user = User::findOne(['username' => $username]);
        if(!empty($user)){
            if($user->password === $user->ofuscatePassword($password)){
                printf("Login valido \n");
                return ExitCode::OK;
            }
        }
        printf("Nel \n");
        return ExitCode::OK;
    }
}

Con esto buscamos un usuario que corresponda uno a uno, si el usuario, ya existe, valida que el password guardado, sea exatamente igual ofuscar el password que esta mandando, si es correcto imprime login valido si no es correcto, en cualtuiqer otro caso dime que no.

Al momento de la verdad, en la terminal 

    $ php yii user/check klvst3r desarrollo

php yii user/check klvst3r desarrollo
Login valido 


Con esto tenemos un sistema de tras de bambalinas que es en el modelo de usurio que funciona y funciona bien, puedo crear un usuario de la manera mas sencilla con la linea de comandos, posterior a ello vamos a crear usuarios nuevos pero el sistema para validar que el usuario y el password correponde es corrcto.





Nos genera un error que viene de c√≥mo est√°s utilizando m√∫ltiples atributos en la instrucci√≥n de Smarty {ActiveForm begin ...}.
Error:

    too many shorthand attributes

Esto significa que Smarty no puede interpretar correctamente la sintaxis porque est√°s usando m√∫ltiples atributos sin agruparlos apropiadamente.
Soluci√≥n: usar with para pasar m√∫ltiples par√°metros

En lugar de pasar varios par√°metros "inline" (como id=, options=, etc.), debes agruparlos usando la sintaxis with.


C√≥digo corregido del template:
------------------------------

{use class="yii\widgets\ActiveForm" type="block"}
{use class="yii\helpers\Html"}

<h1>Registrar nuevo usuario</h1>

{ActiveForm begin with=[
    'id' => 'new-user',
    'options' => ['method' => 'post']
] assign="form"}

    <div class="form-group">
        {$form->field($user, 'username')}
    </div>

{ActiveForm end}



Smarty no permite pasar m√∫ltiples atributos como en PHP directamente (id="..." options=[...] assign="..."), sino que debes agrupar los par√°metros en un solo array usando with=[...].


Modificamos la plantilla
{use class="yii\widgets\ActiveForm" type="block"}
{use class="yii\helpers\Html"}

<h1>Registrar nuevo usuario</h1>

{ActiveForm begin with=array(
    'id' => 'new-user',
    'options' => array('method' => 'post')
) assign="form"}

    <div class="form-group">
        {$form->field($user, 'username')}
    </div>

{ActiveForm end}

Pero nos maneja aun errores.


Utilizamos ahora el codigo para el template
{use class="yii\widgets\ActiveForm" type="block"}
{use class="yii\helpers\Html"}

<h1>Registrar nuevo usuario</h1>

{block ActiveForm}
    <div class="form-group">
        {$form->field($user, 'username')}
    </div>

    <div class="form-group">
        {Html::submitButton('Guardar', array('class' => 'btn btn-primary'))}
    </div>
{/block}

Pero marca un error de 


 PHP Warning ‚Äì yii\base\ErrorException
Undefined array key "form"




ya estamos muy cerca de la soluci√≥n final. Ese error:

    PHP Warning ‚Äì yii\base\ErrorException
    Undefined array key "form"

Significa que dentro del bloque {block ActiveForm}, Smarty no ha creado la variable $form autom√°ticamente. A diferencia de la sintaxis {ActiveForm begin assign="form"}, que s√≠ la asigna, el bloque {block ActiveForm} no crea $form a menos que t√∫ lo captures.
‚úÖ Soluci√≥n

Debes capturar la variable $form t√∫ mismo dentro del bloque. Para hacerlo, cambia:

{block ActiveForm}

por:

{block ActiveForm assign="form"}

Esto le indica a Smarty que el objeto ActiveForm debe asignarse a la variable $form, que luego puedes usar para llamar a field().
‚úÖ Vista new.tpl corregida

{use class="yii\widgets\ActiveForm" type="block"}
{use class="yii\helpers\Html"}

<h1>Registrar nuevo usuario</h1>

{block ActiveForm assign="form"}
    <div class="form-group">
        {$form->field($user, 'username')}
    </div>

    <div class="form-group">
        {Html::submitButton('Guardar', array('class' => 'btn btn-primary'))}
    </div>
{/block}

<script>
document.addEventListener("DOMContentLoaded", function() {
    document.querySelector('form').id = 'new-user';
});
</script>

üß™ Resultado

    Ya no ver√°s el error del array key form.

    Se mostrar√° correctamente el campo de usuario.

    El formulario tendr√° el id="new-user" gracias al JavaScript.

    El bot√≥n de env√≠o ser√° funcional.


Aun se presenta el error:
-------------------------

Dado que el error persiste incluso con {block ActiveForm assign="form"}, vamos a aplicar la soluci√≥n m√°s estable y compatible con Smarty + Yii2: usar begin() y end() del formulario sin asignar a $form, y en su lugar, usar la forma alternativa de imprimir campos directamente.

Paso a paso: c√≥mo hacerlo sin $form

Smarty con yii\smarty\ViewRenderer no siempre puede manejar objetos complejos como $form dentro de las plantillas. Por ello, lo m√°s robusto es construir el formulario en el controlador y pasar los campos ya renderizados a la vista.


Opci√≥n 1 (recomendada): Renderizar campos en el controlador

En el controlador (UserController.php):

public function actionNew()
{
    $user = new User();

    if ($user->load(Yii::$app->request->post()) && $user->validate() && $user->save()) {
        Yii::$app->session->setFlash("success", 'Usuario guardado correctamente');
        return $this->redirect(['site/login']);
    }

    // Creamos el formulario aqu√≠ y renderizamos los campos para pasarlos como strings
    ob_start();
    $form = \yii\widgets\ActiveForm::begin(['id' => 'new-user']);
    echo $form->field($user, 'username');
    echo Html::submitButton('Guardar', ['class' => 'btn btn-primary']);
    \yii\widgets\ActiveForm::end();
    $formHtml = ob_get_clean();

    return $this->render('new.tpl', [
        'formHtml' => $formHtml
    ]);
}

En tu views/user/new.tpl:

{use class="yii\helpers\Html"}

<h1>Registrar nuevo usuario</h1>

{$formHtml nofilter}

    üîÅ nofilter es necesario para que Smarty no escape el HTML del formulario.

‚úÖ Opci√≥n 2 (menos limpia): usar begin/end sin $form

Si quieres seguir usando el enfoque de asignaci√≥n, aunque limitado, podr√≠as intentar:

{use class="yii\widgets\ActiveForm" type="block"}
{use class="yii\helpers\Html"}

<h1>Registrar nuevo usuario</h1>

{ActiveForm begin assign="formTag"}
    {php}
        echo \yii\widgets\ActiveForm::begin(['id' => 'new-user']);
        echo $form->field($user, 'username');
        echo \yii\helpers\Html::submitButton('Guardar', ['class' => 'btn btn-primary']);
        echo \yii\widgets\ActiveForm::end();
    {/php}
{ActiveForm end}

Pero esta segunda opci√≥n no es fiable por c√≥mo Smarty compila los bloques y no siempre reconoce $form como variable accesible.
‚úÖ Conclusi√≥n

La opci√≥n m√°s estable con Smarty es renderizar el formulario completo (o sus partes) en el controlador y pasarlo como HTML puro a la vista, luego imprimirlo con {$formHtml nofilter}.


Finalmente la solucion quedo de la siguiente manera:

En  mi controlador: tengo el siguiente codigo:

Smarty ejecuta el bloque ActiveForm esperando que dentro se definan campos desde cero, pero t√∫ ya est√°s pasando el formulario completo como un string (HTML) generado con ActiveForm::begin() y ActiveForm::end(). Si dejas el bloque, Smarty intentar√° buscar una variable $form que no existe en la vista, porque esa variable fue usada dentro del controlador.

<?php

namespace app\controllers;


use Yii; //Objeto principal de la palicaci√≥n

use yii\web\Controller;

use app\models\User;

use Exception;

use yii\web\HttpException;

use yii\widgets\ActiveForm;

use yii\helpers\Html;

class UserController extends controller {

   public function actionNew()
{
    $user = new User();

    if ($user->load(Yii::$app->request->post()) && $user->validate() && $user->save()) {
        Yii::$app->session->setFlash("success", 'Usuario guardado correctamente');
        return $this->redirect(['site/login']);
    }

    // Creamos el formulario aqu√≠ y renderizamos los campos para pasarlos como strings
    ob_start();
    $form = \yii\widgets\ActiveForm::begin(['id' => 'new-user']);
    echo $form->field($user, 'username');
    echo Html::submitButton('Guardar', ['class' => 'btn btn-primary']);
    \yii\widgets\ActiveForm::end();
    $formHtml = ob_get_clean();

        //return $this->render('new.tpl', ['user' => $user]);
        //return $this->render('new.tpl');
        //return $this->render('new', ['user' => $user]);

     return $this->render('new.tpl', [
        'formHtml' => $formHtml
    ]);
}

}


Vista new.tpl

{use class="yii\helpers\Html"}

<h1>Registrar nuevo usuario</h1>

{$formHtml nofilter}



El bloque:

{block ActiveForm assign="form"}
    ...
{/block}

est√° de m√°s y es lo que sigue provocando errores como:

    Undefined array key "form"

    Html no est√° definido

    Conflictos de renderizaci√≥n duplicada

Qu√© debemos hacer

En nuestra plantilla solo necesitamos el siguiente contenido m√≠nimo y funcional:


Plantilla views/user/new.tpl corregida:




{use class="yii\helpers\Html"}

<h1>Registrar nuevo usuario</h1>

{$formHtml nofilter}





Ya no necesitamos {block ActiveForm} porque el formulario ya fue generado desde el controlador y se pas√≥ como formHtml.

con esto se soluciono el problema de vista y ahora solo falta agregar los demas campos necesarios y el boton veremos como integrarlos.


Como ya no estamos trabajando con bloques y para 


ara agregar un campo de contrase√±a (password) al formulario en Yii 2 usando Smarty, recuerda que ya no est√°s trabajando con bloques {block ActiveForm}, sino que generas el formulario en el controlador y lo pasas como HTML (formHtml).

¬øQu√© necesitamos modificar?


1. Aseg√∫rate de que el modelo User tenga el atributo password

Esto puede venir de una columna en la base de datos o puedes declararlo en el modelo si lo usar√°s solo para validaci√≥n temporal.


2. Modificar el controlador para incluir el campo de contrase√±a


<?php

namespace app\controllers;


use Yii; //Objeto principal de la palicaci√≥n

use yii\web\Controller;

use app\models\User;

use Exception;

use yii\web\HttpException;

use yii\widgets\ActiveForm;

use yii\helpers\Html;

class UserController extends controller {

    public function actionNew()
    {
        $user = new User();

        if ($user->load(Yii::$app->request->post()) && $user->validate() && $user->save()) {
            Yii::$app->session->setFlash("success", 'Usuario guardado correctamente');
            return $this->redirect(['site/login']);
        }

        ob_start();
        $form = \yii\widgets\ActiveForm::begin(['id' => 'new-user']);

        echo $form->field($user, 'username');
        echo $form->field($user, 'password')->passwordInput(); // Campo de contrase√±a

        echo \yii\helpers\Html::submitButton('Guardar', ['class' => 'btn btn-primary']);
        \yii\widgets\ActiveForm::end();

        $formHtml = ob_get_clean();

            //return $this->render('new.tpl', ['user' => $user]);
            //return $this->render('new.tpl');
            //return $this->render('new', ['user' => $user]);

        return $this->render('new.tpl', [
            'formHtml' => $formHtml
        ]);
    }

}

Nos podemos percatar que para el input del password utilizamos:

echo $form->field($user, 'password')->passwordInput(); // üëà Aqu√≠ el campo de contrase√±a


el boton para guardar:
echo \yii\helpers\Html::submitButton('Guardar', ['class' => 'btn btn-primary']);
        \yii\widgets\ActiveForm::end();


y en la plantilla la dejamos talcual:
{use class="yii\helpers\Html"}

<h1>Registrar nuevo usuario</h1>

{$formHtml nofilter}



como nota adicional
    Si queremos guardar la contrase√±a encriptada, no la guardamos directo como viene. Podemos sobreescribir beforeSave() en el modelo User para aplicar 
    
    Yii::$app->security->generatePasswordHash():

public function beforeSave($insert)
{
    if (parent::beforeSave($insert)) {
        if (!empty($this->password)) {
            $this->password = Yii::$app->security->generatePasswordHash($this->password);
        }
        return true;
    }
    return false;
}